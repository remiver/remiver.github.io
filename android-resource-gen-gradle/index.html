<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>Android gradle编译期资源动态生成正确姿势 - Jayl&#39;s blog</title>
    
    <meta name="description" content="公司项目里有编译期代码和资源生成的需求, 之前一直是使用python(甚至还有bat)脚本去处理的, 为了让动态生成的资源参与编译, 先后使用过下面的方法:
 生成到常规资源目录(默认src/main/java和src/main/res). 这样处理的话动态生成的资源会被版本管理系统检测到, 需要一一指定忽略, 或者提交时手动进行排除, 生成的东西多了很难管控, 经常有误提的情况发生. 生成到build下的自定义目录, 通过android gradle plugin提供的sourceSets配置, 将生成的资源目录进行添加. build目录是统一加了忽略配置的, 不会出现上面版本控制的问题, 但是在IDE里的项目结构中会将生成的代码当做普通代码对待, 与手写的代码混在一起, 看起来很难受.  恰好android编译的流程中是有动态生成资源的逻辑的, 比如BuildConfig.java, 生成的资源也会被IDE正确识别为generated resources, 与手写的代码是隔离开的, 于是抽了点时间对这部分的逻辑进行了下研究.
代码生成 这部分没什么好说的, 可以通过自定义的gradle task直接进行处理, 举个简单的例子:
task genJavaCode() { doFirst { String fileContent = &quot;&quot;&quot;// auto-generated code. DO NOT MODIFY! package me.jayl.demo.resgen; public class GeneratedClass { public static String getMessage() { return &quot;message from GeneratedClass!&quot;; } } &quot;&quot;&quot; File genDir = new File( &quot;${project.">
    <meta name="author" content="">
    
    <link href="https://blog.jayl.me/css/github-gist.min.css" rel="stylesheet">
    <link href="https://blog.jayl.me/css/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://blog.jayl.me/img/apple-touch-icon.png">
    <link rel="icon" href="https://blog.jayl.me/img/favicon.ico">
    
    <meta name="generator" content="Hugo 0.55.6" />
    
    <link rel="alternate" type="application/atom+xml" href="https://blog.jayl.me/index.xml" title="Jayl&#39;s blog">
    
    
    
  </head>
  <body class="single">
    <header class="header">
      <div class="wrap">
        
        <p class="logo"><a href="https://blog.jayl.me/">Jayl&#39;s blog</a></p>
        
        
      </div>
    </header>
    
    <main class="main">


<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">Android gradle编译期资源动态生成正确姿势</h1>
    <div class="post-meta">2019.8.16</div>
  </header>
  <div class="post-content">

<p>公司项目里有编译期代码和资源生成的需求, 之前一直是使用python(甚至还有bat)脚本去处理的, 为了让动态生成的资源参与编译, 先后使用过下面的方法:</p>

<ul>
<li>生成到常规资源目录(默认src/main/java和src/main/res). 这样处理的话动态生成的资源会被版本管理系统检测到, 需要一一指定忽略, 或者提交时手动进行排除, 生成的东西多了很难管控, 经常有误提的情况发生.</li>
<li>生成到build下的自定义目录, 通过android gradle plugin提供的sourceSets配置, 将生成的资源目录进行添加. build目录是统一加了忽略配置的, 不会出现上面版本控制的问题, 但是在IDE里的项目结构中会将生成的代码当做普通代码对待, 与手写的代码混在一起, 看起来很难受.</li>
</ul>

<p>恰好android编译的流程中是有动态生成资源的逻辑的, 比如BuildConfig.java, 生成的资源也会被IDE正确识别为generated resources, 与手写的代码是隔离开的, 于是抽了点时间对这部分的逻辑进行了下研究.</p>

<h2 id="代码生成">代码生成</h2>

<p>这部分没什么好说的, 可以通过自定义的gradle task直接进行处理, 举个简单的例子:</p>

<pre><code class="language-groovy">task genJavaCode() {
    doFirst {
        String fileContent = &quot;&quot;&quot;// auto-generated code. DO NOT MODIFY!
package me.jayl.demo.resgen;

public class GeneratedClass {
    public static String getMessage() {
       return &quot;message from GeneratedClass!&quot;;
    }
}
&quot;&quot;&quot;
        File genDir = new File(
                &quot;${project.buildDir.absolutePath}/gen/me/jayl/demo/resgen&quot;)
        genDir.mkdirs()
        FileWriter fw = new FileWriter(new File(&quot;${genDir.absolutePath}/GeneratedClass.java&quot;))
        fw.write(fileContent)
        fw.flush()
    }
}
</code></pre>

<p>实际开发中生成的代码可能会比较复杂, 可以使用javapoet或者其他库, 这里只是演示所以就直接写死了.</p>

<p>上面的例子在build/gen/目录下生成了一个简单的java class代码, 但是直接生成的代码是不会被IDE识别的, 也不会参与编译, 需要我们将对应的路径进行注册:</p>

<h2 id="代码生成task的注册">代码生成task的注册</h2>

<p>android gradle plugin已经提供了将对应的task注册为java代码生成task的接口, 具体可以参考BaseVariant的代码:</p>

<pre><code class="language-java"> 	/**
     * Adds to the variant a task that generates Java source code.
     *
     * This will make the generate[Variant]Sources task depend on this task and add the
     * new source folders as compilation inputs.
     *
     * The new source folders are also added to the model.
     *
     * @param task the task
     * @param sourceFolders the source folders where the generated source code is.
     */
    void registerJavaGeneratingTask(@NonNull Task task, @NonNull File... sourceFolders);

    /**
     * Adds to the variant a task that generates Java source code.
     *
     * This will make the generate[Variant]Sources task depend on this task and add the
     * new source folders as compilation inputs.
     *
     * The new source folders are also added to the model.
     *
     * @param task the task
     * @param sourceFolders the source folders where the generated source code is.
     */
    void registerJavaGeneratingTask(@NonNull Task task, @NonNull Collection&lt;File&gt; sourceFolders);
</code></pre>

<p>关于Variant的信息这里就不详细说明了, 可以简单的理解成每个Variant对应了android编译时的一个完整构建, 我们在build.gradle指定的那些flavor(debug, release和其他自定义的flavor)都对应着一个Variant实例.</p>

<p>有了对应的接口就好说了, 我们可以遍历编译期的每个Variant, 将代码生成对应的task和生成路径进行注册:</p>

<pre><code class="language-groovy">android.applicationVariants.all {
        it.registerJavaGeneratingTask(
          genJavaCode, new File(&quot;${project.buildDir.absolutePath}/gen&quot;))
}
</code></pre>

<p>搞定之后, 重新跑app的编译, 看下task执行流程, 注册的代码生成task已经被添加到task图里执行了:</p>

<p><img src="https://yaym1q.bn.files.1drv.com/y4mqkMkCMQpj0XjasRv2Uk6EexhQYM1bSGx5aQUqVOdwm151SeX2AAyqIGxxP-9_3qHtFs6-3j2OCz9QIOtqPBoCRT2HOvNSkGr5SfETSoCWfA6nJSqYjmYFd8eGj5yIXklJW5vVtYMCIK246uXUZRccCyju_n2ejCuB176zbgs9OkJ6AjzQkE7d9Ny_S0OKVUR7sUz7PVey4ERKKeDdXNcQQ?width=429&amp;height=232&amp;cropmode=none" alt="gradle task execute log" /></p>

<p>Android Studio的项目结构中也可以看到刚刚生成的代码文件已经被正确识别为generated java code, 与BuildConfig一样:</p>

<p><img src="https://yayl1q.bn.files.1drv.com/y4mIEwl-7OJTb_ILSSICExti3g8RhCEU8QrvVuTcthI0HbQpBhFCg9HIfpRdhBu6wb3_dWcq6H87FAz1gBy-FPhMSl9lpeoZDa-h_SMKS2Xmz5eNa6r5zspJsglDFKOLApGnq-NR8gknfUY1YtqW0_xOSBQMj7D5u_Nbp5CZFdV0mvZBQlznanjpvpB3RGF0vp5P4l8fiiWs7LGNWPORr87hA?width=298&amp;height=135&amp;cropmode=none" alt="generated code" /></p>

<h2 id="资源生成的一些不同点">资源生成的一些不同点</h2>

<p>其实再仔细看BaseVariant.java的代码, 会发现plugin中同样提供了资源生成task注册的接口:</p>

<pre><code class="language-java"> 	/**
     * Adds to the variant a task that generates Resources.
     *
     * This will make the generate[Variant]Resources task depend on this task and add the
     * new Resource folders as Resource merge inputs.
     *
     * The Resource folders are also added to the model.
     *
     * @param task the task
     * @param resFolders the folders where the generated resources are.
     *
     * @deprecated Use {@link #registerGeneratedResFolders(FileCollection)}
     */
    @Deprecated
    void registerResGeneratingTask(@NonNull Task task, @NonNull File... resFolders);

    /**
     * Adds to the variant a task that generates Resources.
     *
     * This will make the generate[Variant]Resources task depend on this task and add the
     * new Resource folders as Resource merge inputs.
     *
     * The Resource folders are also added to the model.
     *
     * @param task the task
     * @param resFolders the folders where the generated resources are.
     *
     * @deprecated Use {@link #registerGeneratedResFolders(FileCollection)}
     */
    @Deprecated
    void registerResGeneratingTask(@NonNull Task task, @NonNull Collection&lt;File&gt; resFolders);
</code></pre>

<p>使用方式与java代码生成的task注册是一样的, 但是这两个方法已经被标记为Deprecated了, 建议我们使用新的接口:</p>

<pre><code class="language-java">    /**
     * Adds to the variant new generated resource folders.
     *
     * &lt;p&gt;In order to properly wire up tasks, the FileCollection object must include dependency
     * information about the task that generates the content of this folders.
     *
     * @param folders a FileCollection that contains the folders and the task dependency information
     */
    void registerGeneratedResFolders(@NonNull FileCollection folders);
</code></pre>

<p>新接口中不再接收task作为参数, 只接收了一个FileCollection类型的参数, 同时方法注释里的这句&rdquo;the FileCollection object must include dependency information about the task that generates the content of this folders&rdquo;也是让人一头雾水, 研究了好久终于找到了所谓的&rdquo;dependency information about the task&rdquo;的指定方法:</p>

<pre><code class="language-groovy">ConfigurationFileCollecgtion#builtBy(Object...)
</code></pre>

<p>通过ConfigurableFileCollection的builtBy属性, 可以指定这个路径集合对应的task信息, 剩下的就是正常注册task就好了:</p>

<pre><code class="language-groovy">def genPath = &quot;${project.buildDir.absolutePath}/gen_res&quot;
// task初始化时对自己进行注册, 比如生成资源的task为resGenTask
android.applicationVariants.all {
    it.registerGeneratedResFolders(project.files(new File(genPath)).builtBy(resGenTask))
}
</code></pre>

<p>重新执行编译, 就可以看到资源生成的task和对应路径也被正确处理了.</p>

<h2 id="最后一步-插件编写">最后一步, 插件编写</h2>

<p>上面一直是通过修改module的build.gradle来进行task的定义和注册的, 规范的做法还是要通过定义gradle plugin的方式对我们的资源生成逻辑进行封装, 以便维护和在多个项目中进行复用.</p>

<p>关于gradle plugin的开发, 有很多教程可以参考, 这里就不做详细叙述了. 最后的gradle plugin和上面的逻辑整体是差异不大的, 记录一下关键逻辑:</p>

<pre><code class="language-groovy">class ResgenPlugin implements Plugin&lt;Project&gt; {
    @Override
    void apply(Project project) {
        project.plugins.all {
            // 我们的插件允许被app和library使用, 所以针对application和library类型的module
            // 需要进行一些区分处理
            if (it instanceof AppPlugin) {
                registerGenerateResTask(project,
                        project.extensions.getByType(AppExtension).applicationVariants)
            } else if (it instanceof LibraryPlugin) {
                registerGenerateResTask(project,
                        project.extensions.getByType(LibraryExtension).libraryVariants)
            }
        }
    }

    void registerGenerateResTask(Project project, DomainObjectSet&lt;BaseVariant&gt; variants) {
        variants.all {BaseVariant variant -&gt;
            def resGeneratePath = FileUtil.mergePaths(project.buildDir.absolutePath,
                    &quot;generated/res/resolution&quot;, variant.getDirName())

            Task task = project.task(&quot;generateResolutionResources${variant.name.capitalize()}&quot;) {
                doFirst {
                    // 对应的资源生成逻辑, 此处省略
                    ...
                }
            }

            variant.registerGeneratedResFolders(project.files(new File(resGeneratePath))
                    .builtBy(task))
        }
    }
}
</code></pre>
</div>
  <footer class="post-footer">
    
    <ul class="post-tags">
      
      <li><a href="https://blog.jayl.me/tags/gradle/">gradle</a></li>
      
      <li><a href="https://blog.jayl.me/tags/android/">android</a></li>
      
    </ul>
    
  </footer>
  
  
  
  
</article>

</main>
<footer class="footer">
  <span>&copy; 2019 <a href="https://blog.jayl.me/">Jayl&#39;s blog</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://blog.jayl.me/js/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://blog.jayl.me/js/highlight.pack.js" data-no-instant></script>
<script data-no-instant>
  let body;
  function menuToggleListener() {
    body.classList.toggle('blur');
  }
  function setMenuToggleListener() {
    const menuToggle = document.querySelector('.menu-toggle');
    if (!menuToggle) return;
    body = document.querySelector('body');
    menuToggle.addEventListener('click', menuToggleListener);
  }

  hljs.initHighlightingOnLoad();
  setMenuToggleListener();

  InstantClick.on('change', function () {
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightBlock(block);
    });
    setMenuToggleListener();
  });
</script>
</body>
</html>

